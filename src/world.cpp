// Class automatically generated by Dev-C++ New Class wizard

#include "world.h" // class's header file
#include "trigger.h"
#include "enemy.h"

// class constructor
World::World()
{
}

World::World(const char *file, SoundHandler* sound_handler, bool tileExtractedOption)
{
  // REVISIT: need to read collision map
  char aux_file[100];
  char tileset_file[100];

  pugi::xml_parse_result result = world_file.load_file(file);

  if(!result) {
      printf("Error: loading world data\n");      
  }  

  pugi::xml_node map = world_file.child("map");

  map_width = map.attribute("width").as_int();
  map_height = map.attribute("height").as_int();
  tileset_width = map.attribute("tilewidth").as_int();
  tileset_height = map.attribute("tileheight").as_int();

  pugi::xml_node tileset = world_file.child("map").child("tileset");

  sprintf(aux_file, "%s", file);
  sprintf(tileset_file, "%s/%s", chopToDirectory(aux_file).c_str(), tileset.attribute("name").as_string());

  printf("Tileset file = %s\n", tileset_file);

  world_image = al_load_bitmap(tileset_file);
  if (!world_image) {
    printf("Error: failed to load tileset\n");    
  }

  // Set transparent color for tileset
  al_convert_mask_to_alpha(world_image, al_map_rgb(255,0,255));

  tileset_count = tileset.attribute("tilecount").as_int();
  tileset_columns = tileset.attribute("columns").as_int();
  tileset_tile_width = tileset.attribute("tilewidth").as_int();
  tileset_tile_height = tileset.attribute("tileheight").as_int();

  printf("Tileset count = %d\nTileset columns = %d\nTile width = %d\nTile height = %d\n", tileset_count, tileset_columns, tileset_tile_width, tileset_tile_height);
  
  // Initialize world    
  world_tiles = new Tile**[map_width];
  world_tiles_front = new Tile**[map_width];
  
  for (int x = 0 ; x < map_width ; x++ ) {
      world_tiles[x] = new Tile*[map_height];
      world_tiles_front[x] = new Tile*[map_height];
      for (int y = 0 ; y < map_height ; y++ ) {
        world_tiles[x][y] = new Tile();
        world_tiles_front[x][y] = new Tile();
      }
  }

  // First initialize tiles
  // Tile properties is a layer of same size as tiles, so we can reuse the for stament
  // for both of them. REVISIT: add check to verify they have same size?
  pugi::xml_node xml_tile       = world_file.child("map").find_child_by_attribute("layer", "name", "Tiles").child("data");
  pugi::xml_node xml_tile_front = world_file.child("map").find_child_by_attribute("layer", "name", "FrontTiles").child("data");
  pugi::xml_node xml_tile_prop  = world_file.child("map").find_child_by_attribute("layer", "name", "Collisions").child("data");

  int x = 0;
  int y = 0;
  pugi::xml_node prop       = xml_tile_prop.first_child();
  pugi::xml_node tile_front = xml_tile_front.first_child();
  for (pugi::xml_node tile = xml_tile.first_child(); tile; tile = tile.next_sibling()) {
    pugi::xml_attribute tile_attr       = tile.first_attribute();
    pugi::xml_attribute tile_front_attr = tile_front.first_attribute();
    pugi::xml_attribute prop_attr       = prop.first_attribute();

    int tile_id       = ((tile_attr.as_int() != 0) ? tile_attr.as_int() - 1: tile_attr.as_int());
    int tile_front_id = ((tile_front_attr.as_int() != 0) ? tile_front_attr.as_int() - 1: tile_front_attr.as_int());
    int tile_prop     = ((prop_attr.as_int() != 0) ? prop_attr.as_int() - 1: prop_attr.as_int());
    // Save the id of the tile aswell as the coordinates in the tileset bitmap
    world_tiles[x][y]->SetValue(tile_id);
    world_tiles[x][y]->SetType(tile_prop);
    world_tiles[x][y]->SetLeftUpX((tile_id % tileset_columns) * tileset_width);
    world_tiles[x][y]->SetLeftUpY(ceil(tile_id/tileset_columns)*tileset_height);
    world_tiles[x][y]->SetRightDownX((tile_id % tileset_columns) * tileset_width + tileset_width);
    world_tiles[x][y]->SetRightDownY(ceil((tile_id/tileset_columns))*tileset_height + tileset_height);
    // Same for tiles in front
    world_tiles_front[x][y]->SetValue(tile_front_id);
    world_tiles_front[x][y]->SetType(tile_prop);
    world_tiles_front[x][y]->SetLeftUpX((tile_front_id % tileset_columns) * tileset_width);
    world_tiles_front[x][y]->SetLeftUpY(ceil(tile_front_id/tileset_columns)*tileset_height);
    world_tiles_front[x][y]->SetRightDownX((tile_front_id % tileset_columns) * tileset_width + tileset_width);
    world_tiles_front[x][y]->SetRightDownY(ceil((tile_front_id/tileset_columns))*tileset_height + tileset_height);
    if (x == (map_width - 1)) {
      y++;
      x = 0;
    } else {
      x++;
    }
    // Move prop and front pointer
    prop       = prop.next_sibling();
    tile_front = tile_front.next_sibling();
  }

  // Read platforms
  this->InitializePlatforms("../levels/level1/platforms.xml");
  // Read items
  this->InitializeItems("../levels/level1/items.xml", sound_handler);
  // Read dynamic background objects
  this->InitializeDynamicBackObjects("../levels/level1/anim_tiles.xml");
  // Read blocks
  this->InitializeBlocks("../levels/level1/blocks.xml");
  // Read hazards
  this->InitializeHazards("../levels/level1/hazards.xml");
  // Read checkpoints
  this->InitializeCheckpoints("../levels/level1/checkpoints.xml");
  // Read lasers
  this->InitializeLasers("../levels/level1/lasers.xml");
  // Read triggers
  this->InitializeTriggers("../levels/level1/triggers.xml");
  // Read enemies
  this->InitializeEnemies("../levels/level1/enemies.xml");
  // Read camera views
  this->InitializeCameraViews("../levels/level1/camera_views.xml");

  shoot_exists = false;
  bomb_exists = false;
}

// class destructor
World::~World()
{
  // Delete tiles
//  for( int i = 0 ; i < tiles_m_y ; i++ ) {
//    for( int j = 0 ; j < tiles_m_x ; j++ ) {
//      delete tiles_mundo[i][j];
//    }
//    delete tiles_mundo[i];
//  }
//  delete tiles_mundo;
//    
//  al_destroy_bitmap(world_image);

  // Destroy platforms
  for (vector<Platform*>::iterator it = platforms.begin() ; it != platforms.end(); ++it) {
      delete *it;
  }
  for (list<Object*>::iterator it = objects.begin() ; it != objects.end(); ++it) {
      delete *it;
  }
  for (list<Block*>::iterator it = blocks.begin() ; it != blocks.end(); ++it) {
      delete *it;
  }
  for (list<Checkpoint*>::iterator it = checkpoints.begin() ; it != checkpoints.end(); ++it) {
      delete *it;
  }
  for (vector<CameraView*>::iterator it = camera_views.begin() ; it != camera_views.end(); ++it) {
      delete *it;
  }
}

void World::InitializePlatforms(const char* file) {
  int platform_id;
  int plat_ini_x;
  int plat_ini_y;
  int plat_width;
  int plat_height;
  int plat_visible;
  int plat_recursive;
  int plat_one_use;
  int plat_ini_state;
  int action_direction;
  int action_desp;
  int action_wait;
  float action_speed;
  int action_cond;
  int num_actions;
  pugi::xml_document plat_file;

  printf("---------------------------\n");
  printf("| Initializing platforms  |\n");
  printf("---------------------------\n");

  pugi::xml_parse_result result = plat_file.load_file(file);

  if(!result) {
    printf("Error: loading world platform data\n");
  }
  
  for (pugi::xml_node plat = plat_file.child("platforms").first_child();
       plat;
       plat = plat.next_sibling()) {
    // First read attributes
    platform_id = plat.attribute("id").as_int();
    printf("Platform id = %d\n", platform_id);

    pugi::xml_node plat_attrs = plat.child("attributes");
    plat_ini_x = plat_attrs.attribute("ini_x").as_int();
    plat_ini_y = plat_attrs.attribute("ini_y").as_int();
    plat_width = plat_attrs.attribute("width").as_int();
    plat_height = plat_attrs.attribute("height").as_int();
    plat_visible = plat_attrs.attribute("visible").as_int();
    plat_recursive = plat_attrs.attribute("recursive").as_int();
    plat_one_use = plat_attrs.attribute("one_use").as_int();
    plat_ini_state = strcmp(plat_attrs.attribute("ini_state").as_string(), "stop") == 0 ?
                       OBJ_STATE_STOP :
                       OBJ_STATE_MOVING;
    printf(" - File = %s\n", plat_attrs.attribute("file").as_string());
    printf(" - ini_x = %d\n", plat_ini_x);
    printf(" - ini_y = %d\n", plat_ini_y);
    printf(" - width = %d\n", plat_width);
    printf(" - height = %d\n", plat_height);
    printf(" - visible = %d\n", plat_visible);
    printf(" - recursive = %d\n", plat_recursive);
    printf(" - one_use = %d\n", plat_one_use);
    printf(" - ini_state = %s\n", plat_attrs.attribute("ini_state").as_string());

    // Create platform
    Platform* world_platform = new Platform(plat_attrs.attribute("file").as_string(),
                                            platform_id,
                                            plat_ini_state,
                                            plat_ini_x,
                                            plat_ini_y,
                                            plat_width,
                                            plat_height,
                                            plat_visible,
                                            plat_recursive,
                                            plat_one_use);

    printf(" - actions:\n");
    num_actions = 0;
    // Second, get actions
    pugi::xml_node actions = plat.child("actions");
    for (pugi::xml_node action = actions.first_child();
         action;
         action = action.next_sibling()) {
      printf("\t - action %d:\n", num_actions);
      if (strcmp(action.attribute("direction").as_string(), "stop") == 0) {
        action_direction = OBJ_DIR_STOP;
      } else if (strcmp(action.attribute("direction").as_string(), "right") == 0) {
        action_direction = OBJ_DIR_RIGHT;
      } else if (strcmp(action.attribute("direction").as_string(), "left") == 0) {
        action_direction = OBJ_DIR_LEFT;
      } else if (strcmp(action.attribute("direction").as_string(), "up") == 0) {
        action_direction = OBJ_DIR_UP;
      } else if (strcmp(action.attribute("direction").as_string(), "down") == 0) {
        action_direction = OBJ_DIR_DOWN;
      }
      action_desp = action.attribute("desp").as_int();
      action_wait = action.attribute("wait").as_int();
      action_speed = action.attribute("speed").as_float();      
      action_cond = action.attribute("cond").as_int();
      printf("\t\t - direction=%s\n", action.attribute("direction").as_string());
      printf("\t\t - desp=%d\n", action_desp);
      printf("\t\t - wait=%d\n", action_wait);
      printf("\t\t - speed=%f\n", action_speed);
      printf("\t\t - cond=%d\n", action_cond);

      world_platform->AddAction(action_direction,
                                action_desp,
                                action_wait,
                                action_speed,
                                action_cond);  // REVISIT: no actions for platforms yet
      num_actions++;
    }
    platforms.push_back(world_platform);

  }  

  printf("---------------------------\n");
}

void World::InitializeHazards(const char* file) {
  int   hazard_id;
  int   hazard_ini_x;
  int   hazard_ini_y;
  int   hazard_width;
  int   hazard_height;
  bool  hazard_trigger;
  bool  hazard_stop_inactive;
  int   action_direction;
  int   action_desp;
  int   action_wait;
  float action_speed;
  bool  action_deactivate;
  int   action_cond;
  int   num_actions;  
  pugi::xml_document hazard_file;

  printf("---------------------------\n");
  printf("| Initializing hazards    |\n");
  printf("---------------------------\n");

  pugi::xml_parse_result result = hazard_file.load_file(file);

  if(!result) {
    printf("Error: loading world hazard data\n");
  }
  
  for (pugi::xml_node hazard = hazard_file.child("hazards").first_child();
       hazard;
       hazard = hazard.next_sibling()) {
    // First read attributes
    hazard_id = hazard.attribute("id").as_int();
    printf("Hazard id = %d\n", hazard_id);

    pugi::xml_node hazard_attrs = hazard.child("attributes");
    hazard_ini_x                = hazard_attrs.attribute("ini_x").as_int();
    hazard_ini_y                = hazard_attrs.attribute("ini_y").as_int();
    hazard_width                = hazard_attrs.attribute("width").as_int();
    hazard_height               = hazard_attrs.attribute("height").as_int();
    hazard_trigger              = hazard_attrs.attribute("trigger").as_bool();
    hazard_stop_inactive        = hazard_attrs.attribute("stop_inactive").as_bool();


    printf(" - File = %s\n",          hazard_attrs.attribute("file").as_string());
    printf(" - ini_x = %d\n",         hazard_ini_x);
    printf(" - ini_y = %d\n",         hazard_ini_y);
    printf(" - width = %d\n",         hazard_width);
    printf(" - height = %d\n",        hazard_height);
    printf(" - trigger = %d\n",       hazard_trigger);
    printf(" - stop_inactive = %d\n", hazard_stop_inactive);

    // Create hazard
    Hazard* world_hazard = new Hazard(hazard_attrs.attribute("file").as_string(),
                                      hazard_id,
                                      hazard_ini_x,
                                      hazard_ini_y,
                                      hazard_width,
                                      hazard_height,
                                      hazard_trigger,
                                      hazard_stop_inactive);

    printf(" - actions:\n");
    num_actions = 0;
    // Second, get actions
    pugi::xml_node actions = hazard.child("actions");
    for (pugi::xml_node action = actions.first_child();
         action;
         action = action.next_sibling()) {
      printf("\t - action %d:\n", num_actions);
      action_deactivate = false;
      if (strcmp(action.attribute("direction").as_string(), "stop") == 0) {
        action_direction = OBJ_DIR_STOP;
      } else if (strcmp(action.attribute("direction").as_string(), "right") == 0) {
        action_direction = OBJ_DIR_RIGHT;
      } else if (strcmp(action.attribute("direction").as_string(), "left") == 0) {
        action_direction = OBJ_DIR_LEFT;
      } else if (strcmp(action.attribute("direction").as_string(), "up") == 0) {
        action_direction = OBJ_DIR_UP;
      } else if (strcmp(action.attribute("direction").as_string(), "down") == 0) {
        action_direction = OBJ_DIR_DOWN;
      } else if (strcmp(action.attribute("direction").as_string(), "deactivate") == 0) {
        action_direction = OBJ_DIR_STOP;
        action_deactivate = true;
      }
      action_desp = action.attribute("desp").as_int();
      action_wait = action.attribute("wait").as_int();
      action_speed = action.attribute("speed").as_float();
      action_cond = action.attribute("cond").as_int();
      printf("\t\t - direction=%s\n", action.attribute("direction").as_string());
      printf("\t\t - deactivate=%d\n", (int)action_deactivate);
      printf("\t\t - desp=%d\n", action_desp);
      printf("\t\t - wait=%d\n", action_wait);
      printf("\t\t - speed=%f\n", action_speed);
      printf("\t\t - wait=%d\n", action_cond);

      world_hazard->AddAction(action_direction,
                              action_desp,
                              action_wait,
                              action_speed,
                              !action_deactivate,
                              action_cond);
      num_actions++;
    }
    objects.push_back(world_hazard);

  }  

  printf("---------------------------\n");
}

void World::InitializeItems(const char* file, SoundHandler* sound_handler) {
  int item_id;
  int item_ini_x;
  int item_ini_y;
  int item_width;
  int item_height;  
  pugi::xml_document item_file;

  printf("---------------------------\n");
  printf("| Initializing items      |\n");
  printf("---------------------------\n");

  pugi::xml_parse_result result = item_file.load_file(file);

  if(!result) {
    printf("Error: loading world items data\n");
  }
 
  for (pugi::xml_node item = item_file.child("items").first_child();
       item;
       item = item.next_sibling()) {
    // First read attributes
    item_id = item.attribute("id").as_int();
    printf("Item id = %d\n", item_id);

    pugi::xml_node item_attrs = item.child("attributes");
    item_ini_x  = item_attrs.attribute("ini_x").as_int();
    item_ini_y  = item_attrs.attribute("ini_y").as_int();
    item_width  = item_attrs.attribute("width").as_int();
    item_height = item_attrs.attribute("height").as_int();

    printf(" - File = %s\n", item_attrs.attribute("file").as_string());
    printf(" - ini_x = %d\n", item_ini_x);
    printf(" - ini_y = %d\n", item_ini_y);
    printf(" - width = %d\n", item_width);
    printf(" - height = %d\n", item_height);

    // Create item
    Item* world_item = new Item(item_id);
    world_item->Init(item_attrs.attribute("file").as_string(),
                     item_ini_x, item_ini_y,
                     item_width, item_height,
                     true, true,
                     OBJ_STATE_STOP, OBJ_DIR_STOP,
                     0.1, 3.0, 1.0,
                     0.1, 3.0, 1.0);
    world_item->RegisterSoundHandler(sound_handler);

    objects.push_back(world_item);
  }  

  printf("---------------------------\n");
}

void World::InitializeDynamicBackObjects(const char* file) {
  int dyn_obj_id;
  int dyn_obj_ini_x;
  int dyn_obj_ini_y;
  int dyn_obj_width;
  int dyn_obj_height;
  int dyn_obj_skip_num_anims;
  pugi::xml_document dyn_obj_file;

  printf("------------------------------------------\n");
  printf("| Initializing dynamic backgound objects |\n");
  printf("------------------------------------------\n");

  pugi::xml_parse_result result = dyn_obj_file.load_file(file);

  if(!result) {
    printf("Error: loading world dynamic background objects data\n");
  }
 
  for (pugi::xml_node dyn_obj = dyn_obj_file.child("anim_objects").first_child();
       dyn_obj;
       dyn_obj = dyn_obj.next_sibling()) {
    // First read attributes
    dyn_obj_id = dyn_obj.attribute("id").as_int();
    printf("Dynamic object id = %d\n", dyn_obj_id);

    pugi::xml_node dyn_obj_attrs = dyn_obj.child("attributes");
    dyn_obj_ini_x                = dyn_obj_attrs.attribute("ini_x").as_int();
    dyn_obj_ini_y                = dyn_obj_attrs.attribute("ini_y").as_int();
    dyn_obj_width                = dyn_obj_attrs.attribute("width").as_int();
    dyn_obj_height               = dyn_obj_attrs.attribute("height").as_int();
    dyn_obj_skip_num_anims       = dyn_obj_attrs.attribute("skip_num_anims").as_int();

    printf(" - File = %s\n", dyn_obj_attrs.attribute("file").as_string());
    printf(" - ini_x = %d\n", dyn_obj_ini_x);
    printf(" - ini_y = %d\n", dyn_obj_ini_y);
    printf(" - width = %d\n", dyn_obj_width);
    printf(" - height = %d\n", dyn_obj_height);
    printf(" - skip_anims = %d\n", dyn_obj_skip_num_anims);

    // Create dyn_obj
    StaticObject* world_dyn_obj = new StaticObject(dyn_obj_id);
    world_dyn_obj->Init(dyn_obj_attrs.attribute("file").as_string(),
                        dyn_obj_ini_x, dyn_obj_ini_y,
                        dyn_obj_width, dyn_obj_height,
                        dyn_obj_skip_num_anims);

    back_objects.push_back(world_dyn_obj);
  }  

  printf("---------------------------\n");
}

void World::InitializeBlocks(const char* file) {
  int  block_id;
  int  block_ini_x;
  int  block_ini_y;
  int  block_width;
  int  block_height;
  bool block_exploits;
  pugi::xml_document block_file;

  printf("------------------------------\n");
  printf("| Initializing block objects |\n");
  printf("-----------------------------\n");

  pugi::xml_parse_result result = block_file.load_file(file);

  if(!result) {
    printf("Error: loading world block objects data\n");
  }
 
  for (pugi::xml_node block = block_file.child("blocks").first_child();
       block;
       block = block.next_sibling()) {
    // First read attributes
    block_id = block.attribute("id").as_int();
    printf("Block object id = %d\n", block_id);

    pugi::xml_node block_attrs = block.child("attributes");
    block_ini_x                = block_attrs.attribute("ini_x").as_int();
    block_ini_y                = block_attrs.attribute("ini_y").as_int();
    block_width                = block_attrs.attribute("width").as_int();
    block_height               = block_attrs.attribute("height").as_int();
    block_exploits             = block_attrs.attribute("exploits").as_bool();

    printf(" - File = %s\n", block_attrs.attribute("file").as_string());
    printf(" - ini_x = %d\n", block_ini_x);
    printf(" - ini_y = %d\n", block_ini_y);
    printf(" - width = %d\n", block_width);
    printf(" - height = %d\n", block_height);
    printf(" - exploits = %d\n", (int)block_exploits);

    // Create block
    Block* world_block = new Block(block_id);
    world_block->Init(block_attrs.attribute("file").as_string(),
                      block_ini_x, block_ini_y,
                      block_width, block_height,
                      block_exploits);

    blocks.push_back(world_block);
  }  

  printf("---------------------------\n");
}

void World::InitializeCheckpoints(const char* file) {
  int chk_id;
  int chk_x;
  int chk_y;
  int chk_width;
  int chk_height;
  int pl_x;
  int pl_y;
  int pl_face;
  pugi::xml_document chk_file;
  vector<vector<int> > nxt_chks;

  printf("------------------------------------\n");
  printf("| Initializing checkpoints objects |\n");
  printf("------------------------------------\n");

  pugi::xml_parse_result result = chk_file.load_file(file);

  if(!result) {
    printf("Error: loading world checkpoints data\n");
  }
 
  for (pugi::xml_node chk = chk_file.child("checkpoints").first_child();
       chk;
       chk = chk.next_sibling()) {
    // First read attributes
    chk_id = chk.attribute("id").as_int();
    printf("Checkpoint id = %d\n", chk_id);
    
    chk_x      = chk.attribute("chk_x").as_int();
    chk_y      = chk.attribute("chk_y").as_int();
    chk_width  = chk.attribute("chk_width").as_int();
    chk_height = chk.attribute("chk_height").as_int();
    pl_x       = chk.attribute("pl_x").as_int();
    pl_y       = chk.attribute("pl_y").as_int();
    if (strcmp(chk.attribute("pl_face").as_string(), "right") == 0) {
      pl_face = CHAR_DIR_RIGHT;
    } else if (strcmp(chk.attribute("pl_face").as_string(), "left") == 0) {
      pl_face = CHAR_DIR_LEFT;
    } else {
      printf("Error: incorrect player direction for checkpoint\n");
      exit(-1);
    }

    string nxt_chks_str(chk.attribute("nxt_chks").as_string());
    vector<int> nxt_chks_int;

    stringstream ss(nxt_chks_str);
    string item;    
    while (getline(ss, item, ',')) {
       nxt_chks_int.push_back(stoi(item));
    }
    nxt_chks.push_back(nxt_chks_int);

    printf(" - chk_x = %d\n", chk_x);
    printf(" - chk_y = %d\n", chk_y);
    printf(" - chk_width = %d\n", chk_width);
    printf(" - chk_height = %d\n", chk_height);
    printf(" - pl_x = %d\n", pl_x);
    printf(" - pl_y = %d\n", pl_y);
    printf(" - pl_face = %d\n", pl_face);
    printf(" - nxt_chks=");
    for(vector<int>::iterator it = nxt_chks_int.begin(); it != nxt_chks_int.end(); it++) {
      printf("%d ", *it);
    }
    printf("\n");

    // Create checkpoint
    Checkpoint* world_chk = new Checkpoint(chk_id, chk_x, chk_y, chk_width, chk_height, pl_x, pl_y, pl_face);
    checkpoints.push_back(world_chk);
  }  

  int num_chk = 0;  
  // Once all checkpoints are read, the proceed to link them based on nxt_chks
  for (list<Checkpoint*>::iterator it1 = checkpoints.begin(); it1 != checkpoints.end(); it1++) {
    Checkpoint* chk_orig = *it1;
    // Search for all the checkpoints to be linked
    for (vector<int>::iterator it2 = nxt_chks[num_chk].begin(); it2 != nxt_chks[num_chk].end(); it2++) {
      int num_chk_to_link = *it2;
      // Search this id in the checkpoints list and get the pointer
      bool found = false;
      for (list<Checkpoint*>:: iterator it3 = checkpoints.begin(); it3 != checkpoints.end(); it3++) {
         Checkpoint* chk_to_link = *it3;
         if (chk_to_link->GetChkId() == num_chk_to_link) {
           chk_orig->AddNextCheckpoint(chk_to_link);
           found = true;
         }
      }
      // If not found then return an error
      if (!found) {
        printf("Error: link checkpoint broken for chk_id=%d\n", num_chk);
        exit(-1);
      }
    }
    num_chk++;
  }

  current_checkpoint = *(checkpoints.begin());
  target_checkpoints = current_checkpoint->GetNextCheckpoints();

  printf("---------------------------\n");
}


void World::InitializeTriggers(const char* file) {
  int  trig_id;
  int  trig_x;
  int  trig_y;
  int  trig_width;
  int  trig_height;
  bool trig_recursive;
  int  trig_action;
  int  trig_face;
  int  target_type;
  int  target_id;
  int  target_delay;
  bool target_trigger;
  bool target_trigger_cond;
  int  num_targets;
  pugi::xml_document trig_file;

  printf("---------------------------\n");
  printf("| Initializing triggers   |\n");
  printf("---------------------------\n");

  pugi::xml_parse_result result = trig_file.load_file(file);

  if(!result) {
    printf("Error: loading world trigger data\n");
    exit(-1);
  }
  
  for (pugi::xml_node trig = trig_file.child("triggers").first_child();
       trig;
       trig = trig.next_sibling()) {
    // First read attributes
    trig_id = trig.attribute("id").as_int();
    printf("Trigger id = %d\n", trig_id);

    pugi::xml_node trig_attrs = trig.child("attributes");
    trig_x         = trig_attrs.attribute("x").as_int();
    trig_y         = trig_attrs.attribute("y").as_int();
    trig_width     = trig_attrs.attribute("width").as_int();
    trig_height    = trig_attrs.attribute("height").as_int();
    trig_recursive = trig_attrs.attribute("recursive").as_bool();
    if ((strcmp(trig_attrs.attribute("action").as_string(), "enters")) == 0) {
      trig_action = ACTION_EVENT_ENTERS;
    } else if ((strcmp(trig_attrs.attribute("action").as_string(), "stays")) == 0) {
      trig_action = ACTION_EVENT_STAYS;
    } else if ((strcmp(trig_attrs.attribute("action").as_string(), "exits")) == 0) {
      trig_action = ACTION_EVENT_EXITS;
    } else if ((strcmp(trig_attrs.attribute("action").as_string(), "hits")) == 0) {
      trig_action = ACTION_EVENT_HITS;
    } else {
      printf("Error: wrong action type for trigger!\n");
      exit(-1);
    }

    if ((strcmp(trig_attrs.attribute("face").as_string(), "any")) == 0) {
      trig_face = ACTION_FACE_ANY;
    } else if ((strcmp(trig_attrs.attribute("face").as_string(), "right")) == 0) {
      trig_face = ACTION_FACE_RIGHT;
    } else if ((strcmp(trig_attrs.attribute("face").as_string(), "left")) == 0) {
      trig_face = ACTION_FACE_LEFT;
    } else {
      printf("Error: wrong action face for trigger!\n");
      exit(-1);
    }
    
    printf(" - x = %d\n",      trig_x);
    printf(" - y = %d\n",      trig_y);
    printf(" - width = %d\n",  trig_width);
    printf(" - height = %d\n", trig_height);
    printf(" - recursive = %d\n", trig_recursive);
    printf(" - action = %d\n", trig_action);
    printf(" - face = %d\n",   trig_face);    

    // Create platform
    Trigger* world_trigger = new Trigger(trig_id,
                                         trig_x,
                                         trig_y,
                                         trig_width,
                                         trig_height,
                                         trig_action,
                                         trig_face,
                                         trig_recursive);

    printf(" - targets:\n");
    num_targets = 0;
    // Second, get targets
    pugi::xml_node targets = trig.child("targets");
    for (pugi::xml_node target = targets.first_child();
         target;
         target = target.next_sibling()) {
      printf("\t - target %d:\n", num_targets);
      if (strcmp(target.attribute("type").as_string(), "platform") == 0) {
        target_type = OBJ_PLATFORM;
      } else if (strcmp(target.attribute("type").as_string(), "laser") == 0) {
        target_type = OBJ_LASER;
      } else if (strcmp(target.attribute("type").as_string(), "hazard") == 0) {
        target_type = OBJ_HAZARD;
      } else {
        printf("Error: wrong target id in trigger definiton!\n");
        exit(-1);
      }
      target_id = target.attribute("id").as_int();
      target_delay = target.attribute("delay").as_int();
      target_trigger = target.attribute("trigger").as_bool();
      target_trigger_cond = target.attribute("trigger_cond").as_bool();
      printf("\t\t - type=%s\n", target.attribute("type").as_string());
      printf("\t\t - id=%d\n", target_id);
      printf("\t\t - delay=%d\n", target_delay);
      printf("\t\t - trigger=%d\n", target_trigger);
      printf("\t\t - trigger_cond=%d\n", target_trigger_cond);

      Object* target_ptr;
      if (target_type == OBJ_PLATFORM)
        target_ptr = (Object*)GetPlatform(target_id);
      else if (target_type == OBJ_LASER)
        target_ptr = (Object*)GetLaser(target_id);
      else
        target_ptr = (Object*)GetHazard(target_id);

      if (target_ptr == nullptr) {
        printf("Error: trying to associate an invalid target for this trigger!\n");
        exit(-1);
      }

      world_trigger->AddTarget(target_ptr, target_delay, target_trigger, target_trigger_cond);

      num_targets++;
    }

    triggers.push_back(world_trigger);

  }  

  printf("---------------------------\n");
}

void World::InitializeLasers(const char* file) {
  int   laser_id;
  int   laser_x;
  int   laser_y;
  int   laser_bb_x;
  int   laser_bb_y;
  int   laser_bb_width;
  int   laser_bb_height;
  int   laser_type;
  float laser_speed;
  bool  laser_onehot;
  int   laser_direction;
  int   laser_default_trigger;
  pugi::xml_document laser_file;  

  printf("------------------------------\n");
  printf("| Initializing laser objects |\n");
  printf("------------------------------\n");

  pugi::xml_parse_result result = laser_file.load_file(file);

  if(!result) {
    printf("Error: loading world lasers data\n");
  }
 
  for (pugi::xml_node laser = laser_file.child("lasers").first_child();
       laser;
       laser = laser.next_sibling()) {
    // First read attributes
    laser_id = laser.attribute("id").as_int();
    printf("Laser id = %d\n", laser_id);
    
    laser_x         = laser.attribute("x").as_int();
    laser_y         = laser.attribute("y").as_int();
    laser_bb_x      = laser.attribute("bb_x").as_int();
    laser_bb_y      = laser.attribute("bb_y").as_int();
    laser_bb_width  = laser.attribute("bb_width").as_int();
    laser_bb_height = laser.attribute("bb_height").as_int();
    if (strcmp(laser.attribute("type").as_string(), "horizontal") == 0) {
      laser_type = LASER_TYPE_HORIZONTAL;
    } else if (strcmp(laser.attribute("type").as_string(), "vertical") == 0) {
      laser_type = LASER_TYPE_VERTICAL;
    } else if (strcmp(laser.attribute("type").as_string(), "diagonal") == 0) {
      laser_type = LASER_TYPE_DIAGONAL;
    } else {
      printf("Error: incorrect type for laser\n");
      exit(-1);
    }
    laser_speed = laser.attribute("speed").as_float();
    laser_onehot = !laser.attribute("recursive").as_bool();
    laser_default_trigger = laser.attribute("default_trigger").as_int();
    if (strcmp(laser.attribute("direction").as_string(), "right") == 0) {
      laser_direction = OBJ_DIR_RIGHT;
    } else if (strcmp(laser.attribute("direction").as_string(), "left") == 0) {
      laser_direction = OBJ_DIR_LEFT;
    } else {
      printf("Error: incorrect direction for laser\n");
      exit(-1);
    }
    printf(" - x = %d\n", laser_x);
    printf(" - y = %d\n", laser_y);
    printf(" - bb_x = %d\n", laser_bb_x);
    printf(" - bb_y = %d\n", laser_bb_y);
    printf(" - bb_width = %d\n", laser_bb_width);
    printf(" - bb_height = %d\n", laser_bb_height);
    printf(" - type = %d\n", laser_type);
    printf(" - onehot = %d\n", laser_onehot);
    printf(" - direction = %d\n", laser_direction);
    printf(" - speed = %f\n", laser_speed);
    printf(" - default_trigger = %d\n", laser_default_trigger);

    // Create checkpoint
    Laser* world_laser = new Laser(laser.attribute("file").as_string(),
                                   laser_id,
                                   laser_x, laser_y,
                                   laser_bb_x, laser_bb_y,
                                   laser_bb_width, laser_bb_height,
                                   laser_type, laser_onehot, laser_speed, laser_direction, laser_default_trigger);


    objects.push_back(world_laser);
  }  

  printf("---------------------------\n");
}

void World::InitializeEnemies(const char* file) {
  int   enemy_id;
  int   enemy_x;
  int   enemy_y;
  int   enemy_bb_x;
  int   enemy_bb_y;  
  int   enemy_bb_width;
  int   enemy_bb_height;
  int   enemy_direction;
  float enemy_speed_x;
  float enemy_speed_y;
  int   enemy_ia_type;
  int   enemy_ia_random;
  int   enemy_ia_randomness;
  int   enemy_ia_block_steps;
  int   enemy_ia_orig_x;
  int   enemy_ia_orig_y;
  int   enemy_ia_limit_x;
  int   enemy_ia_limit_y;
  pugi::xml_document enemy_file;

  printf("------------------------------------\n");
  printf("| Initializing enemies             |\n");
  printf("------------------------------------\n");

  pugi::xml_parse_result result = enemy_file.load_file(file);

  if(!result) {
    printf("Error: loading world enemies data\n");
  }
 
  for (pugi::xml_node enemy = enemy_file.child("enemies").first_child();
       enemy;
       enemy = enemy.next_sibling()) {
    // First read attributes
    enemy_id = enemy.attribute("id").as_int();
    printf("Enemy id = %d\n", enemy_id);
    
    enemy_x         = enemy.attribute("x").as_int();
    enemy_y         = enemy.attribute("y").as_int();
    enemy_bb_x      = enemy.attribute("bb_x").as_int();
    enemy_bb_y      = enemy.attribute("bb_y").as_int();
    enemy_bb_width  = enemy.attribute("bb_width").as_int();
    enemy_bb_height = enemy.attribute("bb_height").as_int();
    enemy_speed_x   = enemy.attribute("speed_x").as_float();
    enemy_speed_y   = enemy.attribute("speed_y").as_float();
    if (strcmp(enemy.attribute("direction").as_string(), "right") == 0) {
      enemy_direction = CHAR_DIR_RIGHT;
    } else if (strcmp(enemy.attribute("direction").as_string(), "left") == 0) {
      enemy_direction = CHAR_DIR_LEFT;
    } else {
      printf("Error: incorrect direction for enemy\n");
      exit(-1);
    }
    if (strcmp(enemy.attribute("ia_type").as_string(), "walker") == 0) {
      enemy_ia_type = ENEMY_IA_WALKER;
    } else if (strcmp(enemy.attribute("ia_type").as_string(), "chaser") == 0) {
      enemy_ia_type = ENEMY_IA_CHASER;
    } else {
      printf("Error: incorrect ia type for enemy\n");
      exit(-1);
    }
    enemy_ia_random      = enemy.attribute("ia_random").as_bool();
    enemy_ia_randomness  = enemy.attribute("ia_randomness").as_int();
    enemy_ia_block_steps = enemy.attribute("ia_block_steps").as_int();
    enemy_ia_orig_x      = enemy.attribute("ia_orig_x").as_int();
    enemy_ia_orig_y      = enemy.attribute("ia_orig_y").as_int();
    enemy_ia_limit_x     = enemy.attribute("ia_limit_x").as_int();
    enemy_ia_limit_y     = enemy.attribute("ia_limit_y").as_int();

    printf(" - file = %s\n", enemy.attribute("file").as_string());
    printf(" - x = %d\n", enemy_x);
    printf(" - y = %d\n", enemy_y);
    printf(" - bb_x = %d\n", enemy_bb_x);
    printf(" - bb_y = %d\n", enemy_bb_y);
    printf(" - bb_width = %d\n", enemy_bb_width);
    printf(" - bb_height = %d\n", enemy_bb_height);
    printf(" - speed_x=%f\n", enemy_speed_x);
    printf(" - speed_y=%f\n", enemy_speed_y);
    printf(" - direction = %d\n", enemy_direction);
    printf(" - ia_type = %d\n", enemy_ia_type);
    printf(" - ia_random = %d\n", enemy_ia_random);
    printf(" - ia_randomness = %d\n", enemy_ia_randomness);
    printf(" - ia_block_steps = %d\n", enemy_ia_block_steps);
    printf(" - ia_orig_x = %d\n", enemy_ia_orig_x);
    printf(" - ia_orig_y = %d\n", enemy_ia_orig_y);
    printf(" - ia_limit_x = %d\n", enemy_ia_limit_x);
    printf(" - ia_limit_y = %d\n", enemy_ia_limit_y);

    // Create enemy
    Enemy* world_enemy = new Enemy(enemy.attribute("file").as_string(),
                                   enemy_id,
                                   enemy_x, enemy_y,
                                   enemy_bb_x, enemy_bb_y, enemy_bb_width, enemy_bb_height,
                                   enemy_direction, enemy_speed_x, enemy_speed_y,
                                   enemy_ia_type, enemy_ia_random, enemy_ia_randomness, enemy_ia_block_steps,
                                   enemy_ia_orig_x, enemy_ia_orig_y, enemy_ia_limit_x, enemy_ia_limit_y);
    enemies.push_back(world_enemy);
  }  

  printf("---------------------------\n");
}

void World::InitializeCameraViews(const char* file) {
  int view_id;
  int left_up_x;
  int left_up_y;
  int right_down_x;
  int right_down_y;
  pugi::xml_document view_file;

  printf("------------------------------------\n");
  printf("| Initializing camera views        |\n");
  printf("------------------------------------\n");

  pugi::xml_parse_result result = view_file.load_file(file);

  if(!result) {
    printf("Error: loading world camera view data\n");
  }
 
  for (pugi::xml_node view = view_file.child("views").first_child();
       view;
       view = view.next_sibling()) {
    // First read attributes
    view_id = view.attribute("id").as_int();
    printf("View id = %d\n", view_id);
    
    left_up_x    = view.attribute("left_up_x").as_int();
    left_up_y    = view.attribute("left_up_y").as_int();
    right_down_x = view.attribute("right_down_x").as_int();
    right_down_y = view.attribute("right_down_y").as_int();

    printf(" - left_up_x = %d\n", left_up_x);
    printf(" - left_up_y = %d\n", left_up_y);
    printf(" - right_down_x = %d\n", right_down_x);
    printf(" - right_down_y = %d\n", right_down_y);

    // Create camera view
    CameraView* world_view = new CameraView(view_id, left_up_x, left_up_y, right_down_x, right_down_y);
    camera_views.push_back(world_view);
  }

  printf("---------------------------\n");
}

int World::GetMapWidth() {
   return map_width;
}

int World::GetMapHeight() {
  return map_height;
}

int World::GetTilesetWidth() {
  return tileset_width;
}

int World::GetTilesetHeight() {
  return tileset_height;
}

int World::GetTilesetCount() {
  return tileset_count;
}

int World::GetTilesetColumns() {
  return tileset_columns;
}

int World::GetTilesetTileWidth() {
  return tileset_tile_width;
}

int World::GetTilesetTileHeight() {
  return tileset_tile_height;
}

Tile* World::GetTile(int x, int y) {
  return world_tiles[x][y];
}

Tile* World::GetTileFront(int x, int y) {
  return world_tiles_front[x][y];
}

bool World::IsTileCollisionable(int x, int y) {
  return (world_tiles[x][y]->GetType() == TILE_COL);
}

bool World::IsTileCollisionableDown(int x, int y) {
  return ((world_tiles[x][y]->GetType() == TILE_COL) ||
          (world_tiles[x][y]->GetType() == TILE_COL_DOWN) ||
          (world_tiles[x][y]->GetType() == TILE_STAIRS_TOP));
}

int World::GetTileValue(int x, int y) {
  return world_tiles[x][y]->GetValue();
}

int World::GetTileValueByCoord(int x, int y)
{
  int tile_x = x / tileset_tile_width;
  int tile_y = y / tileset_tile_height;

  return world_tiles[tile_x][tile_y]->GetValue();
}

Tile* World::GetTileByCoord(int x, int y)
{
  int tile_x = x / tileset_tile_width;
  int tile_y = y / tileset_tile_height;

  return world_tiles[tile_x][tile_y];
}

void World::WorldStep(Character* player) {

  // Perform an step of all elements belonging to the world level
  //printf("[WorldStep] Moving platforms...\n");
  for (vector<Platform*>::iterator it = platforms.begin() ; it != platforms.end(); ++it) {
      (*it)->PlatformStep();
      // REVISIT: remove this code
      //if (player->GetState() == CHAR_STATE_HITTING) {
      //  (*it)->SetTrigger();
      //}
  }

  // Back objects (no deleteable)
  //printf("[WorldStep] Moving back objects...\n");
  for (list<Object*>::iterator it = back_objects.begin() ; it != back_objects.end(); ++it) {
    Object* object = *it;
    if (object->GetActive()) {      
      switch (object->GetType()) {
        case OBJ_STATIC:
          ((StaticObject*)object)->StaticObjectStep();
          break;
        default:
          break;
      }
    }
  }

  // Blocks
  //printf("[WorldStep] Moving blocks...\n");
  for (list<Block*>::iterator it = blocks.begin() ; it != blocks.end(); ++it) {
    Block* block = *it;
    if (block->GetState() == OBJ_STATE_DEAD) {
      delete block;
      it = blocks.erase(it);
    } else if (block->GetActive()) {
      block->ObjectStep(this, player);
    }
  }

  // Global objects
  //printf("[WorldStep] Moving global objects...\n");
  for (list<Object*>::iterator it = objects.begin() ; it != objects.end(); ++it) {
    Object* object = *it;

    // REVISIT: to trigger some events. Remove this code
    if (player->GetState() == CHAR_STATE_HITTING) {
      if (object->GetType() == OBJ_HAZARD)
        ((Hazard*)object)->SetTrigger();
    }

    if (object->GetState() == OBJ_STATE_DEAD) {
      //printf("[WorldStep] Object dead %d\n", object->GetId());
      // REVISIT: need to add STATIC OBJECT here? Same for other objects that may persists (LASER)
      switch (object->GetType()) {
        case OBJ_ITEM:
          delete ((Item*)object);
          break;
        case OBJ_SHOOT:
          delete ((Shoot*)object);
          shoot_exists = false;
          break;
        case OBJ_BOMB:
          delete ((Bomb*)object);
          bomb_exists = false;
          break;
        default:
          printf("[WARNING] Unknown object type to be deleted in World!\n");
          break;
      }
      it = objects.erase(it);                            // Remove element if it is dead.
      //printf("[WorldStep] Removed object from object list\n");
    } else if (object->GetActive()) {
      //printf("Object active id = %d, type = %d\n", object->GetId(), object->GetType());
      switch (object->GetType()) {
        case OBJ_ITEM:
          ((Item*)object)->ObjectStep(this, player);
          break;
        case OBJ_STATIC:
          ((StaticObject*)object)->StaticObjectStep();
          break;
        case OBJ_HAZARD:
          ((Hazard*)object)->HazardStep(this, player);
          break;
        case OBJ_LASER:
          ((Laser*)object)->ObjectStep(this, player);
          break;
        case OBJ_SHOOT:
          ((Shoot*)object)->ObjectStep(this, player);
          break;
        case OBJ_BOMB:
          ((Bomb*)object)->ObjectStep(this, player);
          break;
        default:
          break;
      }
    } else {
      printf("Object inactive %d\n", object->GetId());
    }
  }

  // Handle checkpoints
  //printf("[WorldStep] Handling checkpoints...\n");
  if (player->GetState() != CHAR_STATE_DYING) {
    for (vector<Checkpoint*>::iterator it = target_checkpoints->begin(); it != target_checkpoints->end(); it++) {
      Checkpoint* checkpoint = *it;
      if (checkpoint->InCheckpoint(player->GetPosX(), player->GetPosY(),
                                   player->GetWidth(), player->GetHeight())) {
        // player is in a target checkpoint. Move the current_checkpoint.
        current_checkpoint = checkpoint;
        // re-compute target_checkpoints
        target_checkpoints = current_checkpoint->GetNextCheckpoints();
        break;
      }
    }
  }

  // Handle triggers
  for (list<Trigger*>:: iterator it = triggers.begin(); it != triggers.end(); it++) {
    Trigger* trigger = *it;
    trigger->TriggerStep(player->GetPosX(), player->GetPosY(),
                         player->GetWidth(), player->GetHeight(),
                         player->GetDirection(), player->GetState());
  }

  // Handle enemies
  //printf("[WorldStep] Handling enemies...\n");
  for (vector<Character*>::iterator it = enemies.begin(); it != enemies.end(); it++) {
    Enemy* enemy = (Enemy*)*it;
    enemy->CharacterStep(this, player);
  }

  // Check if player has been killed in this step
  // REVISIT: this check can be done at the begginning of this function and avoid
  // traversing some of the list. Triggers for instance is traversed two times.
  if (player->GetKilled()) {
    printf("[WorldStep] Player killed!\n");
    // If player got killed, then reset the triggers
    for (list<Trigger*>:: iterator it = triggers.begin(); it != triggers.end(); it++) {
      Trigger* trigger = *it;
      trigger->Reset();
    }
    // Traverse some objects to reset them if required
    for (list<Object*>::iterator it = objects.begin() ; it != objects.end(); ++it) {
      Object* object = *it;
      if (object->GetType() == OBJ_LASER)
        ((Laser*)object)->Reset();
    }
  }

  //printf("[WorldStep] Completed!\n");  
}

bool World::CreateNewShoot(int x, int y, int direction) {
  bool created = false;
  // Allow only one shoot to be created right now
  if (!shoot_exists) {
    Shoot* shoot = new Shoot("../designs/shoot/shoot.xml", x, y, 12, 6, direction);
    objects.push_back(shoot);
    shoot_exists = true;
    created = true;
  }

  return created;
}

bool World::CreateNewBomb(int x, int y, int direction) {
  bool created = false;
  // Allow only one bomb to be created right now
  if (!bomb_exists) {    
    printf("CreateNewBomb x=%d, y=%d\n", x, y);
    Bomb* shoot = new Bomb("../designs/bomb/bomb.xml", x, y - 1, 25, 22, direction);
    // REVISIT: not sure why height is 16. May it be 17?
    shoot->SetBoundingBox(8, 10, 10, 13);
    objects.push_back(shoot);
    bomb_exists = true;
    created = true;
  }

  return created;
}

Platform* World::GetPlatform(int id) {
  for (vector<Platform*>::iterator it = platforms.begin() ; it != platforms.end(); ++it) {
    Platform* platform = *it;
    if (platform->GetTypeId() == id)
      return platform;
  }

  return nullptr;
}

Hazard* World::GetHazard(int id) {
  for (list<Object*>::iterator it = objects.begin() ; it != objects.end(); ++it) {
    Object* object = *it;

    if ((object->GetType() == OBJ_HAZARD) && (object->GetTypeId() == id))
      return (Hazard*)object;
  }

  return nullptr;
}

Laser* World::GetLaser(int id) {
  for (list<Object*>::iterator it = objects.begin() ; it != objects.end(); ++it) {
    Object* object = *it;

    if ((object->GetType() == OBJ_LASER) && (object->GetTypeId() == id))
      return (Laser*)object;
  }

  return nullptr;
}

CameraView* World::GetCurrentCameraView(Character* player) {
  int player_x;
  int player_y;
  int player_dir;
  CameraView* view;

  // REVISIT: at the moment, camera views are not taking into account vertical movements
  player_dir = player->GetFace();
  player_x   = player->GetPosX() + ((player_dir == CHAR_DIR_RIGHT) ? player->GetWidth() : 0);
  player_y   = player->GetPosY();

  view = nullptr;
  for (vector<CameraView*>::iterator it = camera_views.begin(); it != camera_views.end(); it++) {
    CameraView* view_to_analyze = *it;

    if( (player_x >= view_to_analyze->GetLeftUpX())   &&
        (player_x < view_to_analyze->GetRightDownX()) &&
        (player_y >= view_to_analyze->GetLeftUpY())   &&
        (player_y < view_to_analyze->GetRightDownY())) {
      if(!view) {
        view = view_to_analyze;
      } else {
        if (player_dir & CHAR_DIR_RIGHT) {
          if (view_to_analyze->GetLeftUpX() > view->GetLeftUpX())
            view = view_to_analyze;
        } else if (player_dir & CHAR_DIR_LEFT) {
          if (view_to_analyze->GetLeftUpX() < view->GetLeftUpX())
            view = view_to_analyze;
        }
      }
    }
  }

  return view;
}